# -*- coding: utf-8 -*-
"""emotion_explainer_with_lime_and_gpt2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1euJThqZLx4qZfRyqJRmoU1wGPLyDH-nO
"""

!pip install "transformers>=4.30.0" "torch>=1.13.0" "lime>=0.2.0.1"

# ============================================================
# Emotion-Aware Text Explainer + Response Generator
# ------------------------------------------------------------

# Dependencies:
#   !pip install "transformers>=4.30.0" "torch>=1.13.0" "lime>=0.2.0.1"


# -----------------------------
# 0) Import Required Libraries
# -----------------------------
from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM
from lime.lime_text import LimeTextExplainer
import numpy as np
from IPython.display import display, HTML
from matplotlib.colors import LinearSegmentedColormap

# ============================================================
# 1) Emotion Detection Model
# ============================================================
# Load a pre-trained transformer model fine-tuned for emotion classification.
# The model â€œj-hartmann/emotion-english-distilroberta-baseâ€
# recognizes 7 emotions: joy, sadness, anger, fear, disgust, surprise, and neutral.

emotion_pipe = pipeline(
    "text-classification",
    model="j-hartmann/emotion-english-distilroberta-base",
    return_all_scores=True  # Return probability scores for all emotions
)

# Extract emotion labels from one sample prediction
_sample = emotion_pipe("hello world")[0]
EMOTION_LABELS = [d['label'] for d in _sample]

def emotion_predict_proba(texts):
    """
    Compute emotion probabilities for each text.
    Input: list of strings
    Output: numpy array of shape (n_texts, n_labels)
    """
    raw = emotion_pipe(texts)
    probs = []
    for item in raw:
        # Convert list of dicts -> ordered probability vector
        label_to_score = {d['label']: d['score'] for d in item}
        probs.append([label_to_score.get(lbl, 0.0) for lbl in EMOTION_LABELS])
    return np.array(probs)

def get_emotion_label(text):
    """
    Predict the most likely emotion label for a given text.
    Returns:
        label (str): predicted emotion
        score (float): confidence score
    """
    probs = emotion_predict_proba([text])[0]
    idx = np.argmax(probs)
    return EMOTION_LABELS[idx], probs[idx]

# ============================================================
# 2) Explainability using LIME
# ============================================================
# LIME (Local Interpretable Model-agnostic Explanations)
# helps identify which words in the input text contributed
# the most to a specific emotion prediction.

explainer = LimeTextExplainer(class_names=EMOTION_LABELS)

def explain_emotion(text):
    """
    Run LIME explanation for a given text.
    Returns: dict of word -> weight
    """
    exp = explainer.explain_instance(
        text_instance=text,
        classifier_fn=emotion_predict_proba,
        num_features=10  # number of influential words to display
    )
    weights = dict(exp.as_list())
    return weights

# ============================================================
# 3) Visualization: Heatmap Coloring for Words
# ============================================================
# We create a custom color map that shades words based on their LIME weight.


cmap = LinearSegmentedColormap.from_list("emotion", ["#add8e6", "#ffffff", "#ff9999"])

def colorize_text(text, weights):
    """
    Highlight each word according to its importance weight.
    Output: HTML for visualization
    """
    words = text.split()
    max_abs = max(abs(v) for v in weights.values()) if weights else 1
    html = ""
    for w in words:
        val = weights.get(w, 0.0)
        # Normalize between 0 and 1
        norm = (val + max_abs) / (2 * max_abs)
        color = cmap(norm)
        rgb = f"rgb({int(color[0]*255)}, {int(color[1]*255)}, {int(color[2]*255)})"
        html += f"<span style='background-color:{rgb}; padding:2px 4px; border-radius:4px'>{w}</span> "
    return html

# ============================================================
# 4) Text Generation Model (GPT-2)
# ============================================================
# This section uses GPT-2 to generate a response tailored
# to the detected emotion.

generator = pipeline("text-generation", model="gpt2", max_length=50, temperature=0.8)

def generate_response(emotion_label):
    """
    Generate a response message based on the detected emotion.
    Each emotion uses a different starting prompt.
    """
    prompts = {
        "joy": "That's wonderful! It sounds like you're full of happiness. Here's a cheerful thought:",
        "sadness": "I'm sorry to hear that. Sometimes expressing our feelings helps. Here's something comforting:",
        "anger": "I can sense some anger there. Let's take a deep breath and think calmly:",
        "fear": "Feeling scared is normal. Here's a reassuring thought:",
        "disgust": "That must have been unpleasant. Here's something to clear your mind:",
        "surprise": "Wow! That sounds surprising. Here's how you could respond positively:"
    }

    prompt = prompts.get(emotion_label, "Here's my response:")
    result = generator(prompt, max_length=60, num_return_sequences=1)[0]["generated_text"]
    return result

# ============================================================
# 5) Run the Full Pipeline
# ============================================================

# Example input
text = "I am so nervous and a bit scared about the exam tomorrow."

# Step 1: Predict emotion
emotion_label, confidence = get_emotion_label(text)

# Step 2: Explain which words influenced the decision
weights = explain_emotion(text)

# Step 3: Visualize important words
colored_text = colorize_text(text, weights)
display(HTML(colored_text))

# Step 4: Show results
print(f"ðŸŽ¯ Detected Emotion: {emotion_label} ({confidence:.3f})")
print("ðŸ§  Words affecting prediction (LIME):")
print(weights)
print("\nðŸ’¬ AI Generated Response:")
print(generate_response(emotion_label))